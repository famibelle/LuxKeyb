package com.example.kreyolkeyboard

import android.content.Context
import android.graphics.Color
import android.graphics.PorterDuff
import android.graphics.Typeface
import android.graphics.drawable.GradientDrawable
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import androidx.core.content.ContextCompat

/**
 * Gestionnaire responsable de la cr√©ation et du stylisme des layouts de clavier
 * S√©pare la logique de cr√©ation des touches du service principal
 */
class KeyboardLayoutManager(private val context: Context) {
    
    companion object {
        private const val BUTTON_HEIGHT_DP = 48
        private const val BUTTON_MARGIN_DP = 2
        private const val CORNER_RADIUS_DP = 8f
        private const val TEXT_SIZE_SP = 16f
        private const val SHADOW_RADIUS = 4f
        private const val TAG = "KeyboardLayoutManager"
        
        // üåê D√©lai pour l'appui long sur la barre d'espace (1 seconde)
        private const val SPACE_LONG_PRESS_DELAY = 1000L
    }
    
    // √âtat du clavier
    private var isCapitalMode = false
    private var isCapsLock = false
    private var isNumericMode = false // FORCE ALPHAB√âTIQUE PAR D√âFAUT
    private val keyboardButtons = mutableListOf<View>()
    
    // üåê Handler pour l'appui long personnalis√© de la barre d'espace
    private val spaceLongPressHandler = Handler(Looper.getMainLooper())
    private var spaceLongPressRunnable: Runnable? = null
    private var isSpaceLongPressTriggered = false
    
    init {
        // Garantir que le clavier d√©marre toujours en mode alphab√©tique
        ensureAlphabeticMode()
    }
    
    // Callbacks pour l'interaction avec les touches
    interface KeyboardInteractionListener {
        fun onKeyPress(key: String)
        fun onLongPress(key: String, button: TextView, isCapitalMode: Boolean)
        fun onKeyRelease()
    }
    
    private var interactionListener: KeyboardInteractionListener? = null
    
    fun setInteractionListener(listener: KeyboardInteractionListener) {
        this.interactionListener = listener
    }
    
    /**
     * Cr√©e le layout principal du clavier avec toutes les rang√©es
     */
    fun createKeyboardLayout(): LinearLayout {
        Log.d("KeyboardLayoutManager", "üéØ createKeyboardLayout - isNumericMode: $isNumericMode")
        
        val mainLayout = LinearLayout(context).apply {
            orientation = LinearLayout.VERTICAL
            setPadding(
                dpToPx(8), dpToPx(8), 
                dpToPx(8), dpToPx(8)
            )
        }
        
        // Cr√©er les diff√©rentes rang√©es selon le mode
        when {
            isNumericMode -> {
                Log.d("KeyboardLayoutManager", "üî¢ Cr√©ation du layout NUM√âRIQUE")
                createNumericLayout(mainLayout)
            }
            else -> {
                Log.d("KeyboardLayoutManager", "üî§ Cr√©ation du layout ALPHAB√âTIQUE")
                createAlphabeticLayout(mainLayout)
            }
        }
        
        return mainLayout
    }
    
    /**
     * Cr√©e le layout alphab√©tique (AZERTY cr√©ole)
     */
    private fun createAlphabeticLayout(mainLayout: LinearLayout) {
        val row1 = arrayOf("a", "z", "e", "r", "t", "y", "u", "i", "o", "p")
        val row2 = arrayOf("q", "s", "d", "f", "g", "h", "j", "k", "l", "m")
        val row3 = arrayOf("‚áß", "w", "x", "c", "v", "b", "n", "‚å´")
        val row4 = arrayOf("123", ",", "√©", " ", "√´", ".", "'", "‚èé")
        
        mainLayout.addView(createKeyboardRow(row1))
        mainLayout.addView(createKeyboardRow(row2))
        mainLayout.addView(createKeyboardRow(row3))
        mainLayout.addView(createKeyboardRow(row4))
    }
    
    /**
     * Cr√©e le layout num√©rique
     */
    private fun createNumericLayout(mainLayout: LinearLayout) {
        val row1 = arrayOf("1", "2", "3", "4", "5", "6", "7", "8", "9", "0")
        val row2 = arrayOf("-", "/", ":", ";", "(", ")", "‚Ç¨", "&", "@", "\"")
        val row3 = arrayOf("=", ".", ",", "?", "!", "'", "\"", "_", "‚å´")
        val row4 = arrayOf("ABC", " ", "‚èé")
        
        mainLayout.addView(createKeyboardRow(row1))
        mainLayout.addView(createKeyboardRow(row2))
        mainLayout.addView(createKeyboardRow(row3))
        mainLayout.addView(createKeyboardRow(row4))
    }
    
    /**
     * Cr√©e une rang√©e de touches
     */
    private fun createKeyboardRow(keys: Array<String>): LinearLayout {
        val rowLayout = LinearLayout(context).apply {
            orientation = LinearLayout.HORIZONTAL
            layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            ).apply {
                setMargins(0, dpToPx(2), 0, dpToPx(2))
            }
        }
        
        val totalWeight = calculateRowWeight(keys)
        
        for (key in keys) {
            val button = createKeyButton(key, totalWeight)
            rowLayout.addView(button)
            keyboardButtons.add(button)
        }
        
        return rowLayout
    }
    
    /**
     * üé® Mappe chaque touche sp√©ciale √† son ic√¥ne Material Design
     */
    private fun getIconForKey(key: String): Int? {
        return when(key) {
            "‚áß" -> R.drawable.ic_keyboard_arrow_up    // Majuscule/Shift
            "‚å´" -> R.drawable.ic_backspace             // Supprimer
            "‚èé" -> R.drawable.ic_keyboard_return       // Entr√©e
            "123" -> R.drawable.ic_dialpad             // Mode num√©rique
            "ABC" -> R.drawable.ic_keyboard            // Mode alphab√©tique
            " " -> R.drawable.ic_space_bar             // Barre d'espace
            else -> null // Touches normales = texte
        }
    }
    
    /**
     * Cr√©e un bouton de touche individuel (texte ou ic√¥ne)
     */
    private fun createKeyButton(key: String, totalWeight: Float): View {
        val iconRes = getIconForKey(key)
        
        return if (iconRes != null) {
            // Touche avec ic√¥ne ‚Üí ImageButton
            createImageKeyButton(key, iconRes, totalWeight)
        } else {
            // Touche avec texte ‚Üí Button standard
            createTextKeyButton(key, totalWeight)
        }
    }
    
    /**
     * üñºÔ∏è Cr√©e un bouton avec ic√¥ne Material Design
     */
    private fun createImageKeyButton(key: String, iconRes: Int, totalWeight: Float): ImageButton {
        val button = ImageButton(context).apply {
            setImageResource(iconRes)
            scaleType = ImageView.ScaleType.CENTER_INSIDE
            setPadding(dpToPx(8), dpToPx(8), dpToPx(8), dpToPx(8))
            contentDescription = when(key) {
                "‚áß" -> "Majuscule"
                "‚å´" -> "Supprimer"
                "‚èé" -> "Entr√©e"
                "123" -> "Mode num√©rique"
                "ABC" -> "Mode alphab√©tique"
                " " -> "Espace"
                else -> key
            }
            
            // Calcul du poids selon le type de touche
            val weight = getKeyWeight(key)
            layoutParams = LinearLayout.LayoutParams(
                0,
                dpToPx(BUTTON_HEIGHT_DP),
                weight
            ).apply {
                setMargins(
                    dpToPx(BUTTON_MARGIN_DP), 0, 
                    dpToPx(BUTTON_MARGIN_DP), 0
                )
            }
        }
        
        // Application du style Guadeloupe
        applyGuadeloupeStyle(button, key)
        
        // Ajouter le bouton √† la liste de suivi
        keyboardButtons.add(button)
        
        // Configuration des √©v√©nements tactiles
        setupButtonInteractions(button, key)
        
        return button
    }
    
    /**
     * üìù Cr√©e un bouton avec texte (touches alphab√©tiques)
     */
    private fun createTextKeyButton(key: String, totalWeight: Float): Button {
        val button = Button(context).apply {
            text = getDisplayText(key)
            // Taille de police personnalis√©e pour Potomitan‚Ñ¢ branding discret
            textSize = if (key == " ") TEXT_SIZE_SP * 0.75f else TEXT_SIZE_SP
            setTypeface(typeface, Typeface.BOLD)
            
            // Calcul du poids selon le type de touche
            val weight = getKeyWeight(key)
            layoutParams = LinearLayout.LayoutParams(
                0,
                dpToPx(BUTTON_HEIGHT_DP),
                weight
            ).apply {
                setMargins(
                    dpToPx(BUTTON_MARGIN_DP), 0, 
                    dpToPx(BUTTON_MARGIN_DP), 0
                )
            }
        }
        
        // Application du style Guadeloupe
        applyGuadeloupeStyle(button, key)
        
        // Ajouter le bouton √† la liste de suivi
        keyboardButtons.add(button)
        
        // Configuration des √©v√©nements tactiles
        setupButtonInteractions(button, key)
        
        return button
    }
    
    /**
     * Applique le style visuel minimaliste moderne (support Button et ImageButton)
     */
    private fun applyGuadeloupeStyle(view: View, key: String) {
        val drawable = GradientDrawable().apply {
            cornerRadius = dpToPx(CORNER_RADIUS_DP.toInt()).toFloat()
            
            // Design minimaliste uniforme : fond blanc avec l√©g√®re variation pour Shift actif
            when (key) {
                "‚áß" -> {
                    if (isCapsLock || isCapitalMode) {
                        // Shift actif : fond gris clair
                        setColor(Color.parseColor("#E0E0E0"))
                    } else {
                        // Shift inactif : blanc
                        setColor(Color.parseColor("#FFFFFF"))
                    }
                }
                else -> {
                    // Toutes les touches : fond blanc uniforme
                    setColor(Color.parseColor("#FFFFFF"))
                }
            }
            
            // Bordure subtile gris clair
            setStroke(dpToPx(1), Color.parseColor("#D0D0D0"))
        }
        
        view.background = drawable
        
        // üé® Couleur du texte/ic√¥ne : noir/gris fonc√© uniforme
        when (view) {
            is Button -> {
                view.setTextColor(Color.parseColor("#333333"))
                // Ombre port√©e l√©g√®re pour l'effet de profondeur
                view.setShadowLayer(SHADOW_RADIUS, 0f, dpToPx(1).toFloat(), Color.parseColor("#40000000"))
            }
            is ImageButton -> {
                // Ic√¥nes en gris fonc√© uniforme
                view.setColorFilter(Color.parseColor("#333333"), PorterDuff.Mode.SRC_IN)
            }
        }
    }
    
    /**
     * Configure les interactions tactiles pour un bouton
     */
    private fun setupButtonInteractions(view: View, key: String) {
        view.setOnClickListener {
            interactionListener?.onKeyPress(key)
        }
        
        // üåê Appui long personnalis√© pour la barre d'espace (1 seconde)
        if (key == " ") {
            view.setOnLongClickListener(null) // D√©sactiver le listener par d√©faut
            setupSpaceLongPress(view, key)
        } else {
            view.setOnLongClickListener { 
                interactionListener?.onLongPress(key, view as TextView, isCapitalMode)
                true
            }
            // Animation tactile pour les touches autres que la barre d'espace
            addTouchAnimation(view)
        }
    }
    
    /**
     * üåê Configure l'appui long personnalis√© de 1 seconde pour la barre d'espace
     */
    private fun setupSpaceLongPress(view: View, key: String) {
        view.setOnTouchListener { v, event ->
            when (event.action) {
                android.view.MotionEvent.ACTION_DOWN -> {
                    isSpaceLongPressTriggered = false
                    
                    // Animation d'appui (100ms)
                    v.animate()
                        .scaleX(0.95f)
                        .scaleY(0.95f)
                        .setDuration(100)
                        .start()
                    
                    // Feedback haptique
                    performHapticFeedback(v)
                    
                    // D√©marrer le timer de 1 seconde pour l'appui long
                    spaceLongPressRunnable = Runnable {
                        isSpaceLongPressTriggered = true
                        Log.d(TAG, "‚è±Ô∏è Appui long 1s d√©tect√© sur barre d'espace")
                        interactionListener?.onLongPress(key, view as TextView, isCapitalMode)
                    }
                    spaceLongPressHandler.postDelayed(spaceLongPressRunnable!!, SPACE_LONG_PRESS_DELAY)
                    
                    false
                }
                android.view.MotionEvent.ACTION_UP -> {
                    // Annuler le timer si rel√¢ch√© avant 1 seconde
                    spaceLongPressRunnable?.let { spaceLongPressHandler.removeCallbacks(it) }
                    
                    // Animation de rel√¢chement (120ms)
                    v.animate()
                        .scaleX(1.0f)
                        .scaleY(1.0f)
                        .setDuration(120)
                        .start()
                    
                    interactionListener?.onKeyRelease()
                    
                    // Si rel√¢ch√© rapidement (pas d'appui long), c'est un clic normal
                    if (!isSpaceLongPressTriggered) {
                        interactionListener?.onKeyPress(key)
                    }
                    
                    false
                }
                android.view.MotionEvent.ACTION_CANCEL -> {
                    // Annuler le timer en cas d'annulation
                    spaceLongPressRunnable?.let { spaceLongPressHandler.removeCallbacks(it) }
                    
                    // Animation de rel√¢chement (120ms)
                    view.animate()
                        .scaleX(1.0f)
                        .scaleY(1.0f)
                        .setDuration(120)
                        .start()
                    
                    interactionListener?.onKeyRelease()
                    false
                }
                else -> false
            }
        }
    }
    
    /**
     * Ajoute une animation tactile et feedback haptique au bouton
     */
    private fun addTouchAnimation(view: View) {
        view.setOnTouchListener { v, event ->
            when (event.action) {
                android.view.MotionEvent.ACTION_DOWN -> {
                    // Animation d'appui (100ms comme l'original)
                    v.animate()
                        .scaleX(0.95f)
                        .scaleY(0.95f)
                        .setDuration(100)
                        .start()
                    
                    // üì≥ FEEDBACK HAPTIQUE MODERNE
                    performHapticFeedback(v)
                    
                    false
                }
                android.view.MotionEvent.ACTION_UP, 
                android.view.MotionEvent.ACTION_CANCEL -> {
                    // Animation de rel√¢chement (120ms comme l'original)
                    v.animate()
                        .scaleX(1.0f)
                        .scaleY(1.0f)
                        .setDuration(120)
                        .start()
                    
                    interactionListener?.onKeyRelease()
                    false
                }
                else -> false
            }
        }
    }
    
    /**
     * Ex√©cute le feedback haptique classique (comme dans la version originale)
     */
    private fun performHapticFeedback(view: android.view.View) {
        try {
            // Feedback haptique l√©ger (identique √† la version originale)
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
                view.performHapticFeedback(
                    android.view.HapticFeedbackConstants.KEYBOARD_TAP,
                    android.view.HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING
                )
            }
        } catch (e: Exception) {
            // Silencieusement ignorer si feedback haptique non support√©
            Log.d(TAG, "Feedback haptique non disponible: ${e.message}")
        }
    }
    
    /**
     * Met √† jour l'affichage du clavier selon l'√©tat actuel
     */
    
    /**
     * Met √† jour les √©tats internes du clavier
     */
    fun updateKeyboardStates(isNumeric: Boolean, isCapital: Boolean, isCapsLock: Boolean) {
        Log.e("SHIFT_REAL_DEBUG", "üö® UPDATING KEYBOARD STATES! isCapital=$isCapital, isCapsLock=$isCapsLock")
        this.isNumericMode = isNumeric
        this.isCapitalMode = isCapital
        this.isCapsLock = isCapsLock
    }

    fun updateKeyboardDisplay() {
        Log.e("SHIFT_REAL_DEBUG", "üö®üö®üö® updateKeyboardDisplay() CALLED! üö®üö®üö®")
        
        val shiftButtons = keyboardButtons.filter { getKeyFromButton(it) == "‚áß" }
        Log.e("SHIFT_REAL_DEBUG", "üî¢ NOMBRE DE BOUTONS SHIFT TROUV√âS: ${shiftButtons.size}")
        Log.e("SHIFT_REAL_DEBUG", "üìä √âTAT ACTUEL: isCapitalMode=$isCapitalMode, isCapsLock=$isCapsLock")
        
        keyboardButtons.forEach { view ->
            val key = getKeyFromButton(view)
            
            // Mise √† jour du texte pour les Button uniquement
            if (view is Button) {
                view.text = getDisplayText(key)
            }
            
            // Mise √† jour du style pour la touche Shift
            if (key == "‚áß") {
                Log.e("SHIFT_REAL_DEBUG", "üö® UPDATING SHIFT BUTTON! isCapitalMode=$isCapitalMode, isCapsLock=$isCapsLock")
                applyGuadeloupeStyle(view, key)
                Log.e("SHIFT_REAL_DEBUG", "üö® SHIFT STYLE APPLIED!")
            }
        }
    }
    
    /**
     * Commute entre les modes majuscule/minuscule
     */
    fun toggleCapsMode(): Boolean {
        when {
            !isCapitalMode && !isCapsLock -> {
                isCapitalMode = true
                isCapsLock = false
            }
            isCapitalMode && !isCapsLock -> {
                isCapitalMode = true
                isCapsLock = true
            }
            else -> {
                isCapitalMode = false
                isCapsLock = false
            }
        }
        // ‚ùå SUPPRIM√â: updateKeyboardDisplay() - d√©j√† appel√© par InputProcessor
        Log.e("SHIFT_REAL_DEBUG", "üö® toggleCapsMode: isCapital=$isCapitalMode, isCapsLock=$isCapsLock")
        return isCapitalMode
    }
    
    /**
     * Commute entre mode alphab√©tique et num√©rique
     */
    fun switchKeyboardMode(): Boolean {
        isNumericMode = !isNumericMode
        return isNumericMode
    }
    
    /**
     * Force le mode alphab√©tique (pour l'initialisation)
     */
    fun switchKeyboardModeToAlphabetic() {
        isNumericMode = false
        Log.d("KeyboardLayoutManager", "üî§ MODE FORC√â √Ä ALPHAB√âTIQUE")
    }
    
    /**
     * Garantit que le clavier d√©marre en mode alphab√©tique
     */
    private fun ensureAlphabeticMode() {
        isNumericMode = false
        isCapitalMode = false
        isCapsLock = false
        Log.d("KeyboardLayoutManager", "üöÄ INITIALISATION : Mode alphab√©tique garanti")
    }
    
    /**
     * Force publiquement le retour au mode alphab√©tique
     */
    fun forceAlphabeticMode() {
        ensureAlphabeticMode()
        Log.d("KeyboardLayoutManager", "üîÑ FORCE : Retour au mode alphab√©tique")
    }
    
    /**
     * Nettoie les ressources
     */
    fun cleanup() {
        keyboardButtons.forEach { view ->
            cleanupView(view)
        }
        keyboardButtons.clear()
        interactionListener = null
    }
    
    // M√©thodes utilitaires priv√©es
    
    private fun getDisplayText(key: String): String {
        return when (key) {
            " " -> "üá±üá∫Potomitan‚Ñ¢"
            "‚áß" -> "‚áß"
            "‚å´" -> "‚å´"
            "‚èé" -> "‚èé"
            "123" -> if (isNumericMode) "ABC" else "123"
            // Tous les autres caract√®res (y compris les accentu√©s) suivent la capitalisation
            else -> if (isCapitalMode) key.uppercase() else key.lowercase()
        }
    }
    
    private fun getKeyWeight(key: String): Float {
        return when (key) {
            " " -> 4.0f      // Barre d'espace plus large
            "‚áß", "‚å´" -> 1.5f // Touches de fonction plus larges
            else -> 1.0f     // Touches normales
        }
    }
    
    private fun calculateRowWeight(keys: Array<String>): Float {
        return keys.sumOf { getKeyWeight(it).toDouble() }.toFloat()
    }
    
    private fun getKeyFromButton(view: View): String {
        // Pour ImageButton, utiliser contentDescription
        if (view is ImageButton) {
            return when(view.contentDescription) {
                "Majuscule" -> "‚áß"
                "Supprimer" -> "‚å´"
                "Entr√©e" -> "‚èé"
                "Mode num√©rique" -> "123"
                "Mode alphab√©tique" -> "ABC"
                "Espace" -> " "
                else -> ""
            }
        }
        // Pour Button avec texte, utiliser le texte affich√©
        if (view is Button) {
            return view.text.toString().lowercase()
        }
        return ""
    }
    
    private fun dpToPx(dp: Int): Int {
        return (dp * context.resources.displayMetrics.density).toInt()
    }
    
    private fun cleanupView(view: View) {
        view.setOnClickListener(null)
        view.setOnLongClickListener(null)
        view.setOnTouchListener(null)
        view.background = null
        
        // Nettoyer les animations en cours
        view.animate().cancel()
        view.clearAnimation()
        
        // Nettoyer les r√©f√©rences du parent
        (view.parent as? ViewGroup)?.removeView(view)
    }
}
